init：初始化空闲块数，位示图，页表，进程表

空闲块数初始值为页框总数
位示图全部清0
页表：每个页表项中的页框号都置为0，标志位也置0
进程表：1024个表项，全部置0

1）创建

创建一个进程，分配1MB的内存
此时在进程表中开始查找，如果有一个进程表项的pid为0，那么说明该表项为空，将进程号填入，然后pageFrameSize就是分配的内存的页框数（向上取整）
先看空闲块数是否还足够，如果不足，直接返回。
如果足够，那么取出页表，然后在页表中找连续的页表项，如果有连续的满足需求的页表项，就把这些然后每个页表项中都要去位示图中的开始找，先看空闲块数是否还足够，如果足够，那么从头遍历找不为0的块，将位示图中的块的占用位置为1，空闲块的位置转为页框号（第一个空闲块对应的是第一个页框），返回页框号，填入页表项，并将页表项的占用标识置为1，主存驻留标识置为1，空闲块数减一。
再看下一个页表项，如此反复直至内存分配完毕。
分配完毕后，返回第一个页表项的索引，填入PCB的页表开始位置。完毕。

返回的虚拟内存地址，是页号和页内偏移的拼接，都是0。

2）读
给一个虚拟内存地址（从0开始），将虚拟内存地址拆成页号和页内偏移（前20位是页号，后12位是页内偏移）
首先是根据pid查该进程的内存在页表中的起址，然后比较进程分配得到的页数pageSize和页号，如果越界，那么拒绝访问。如果没有越界，那么由起址+页号得到对应的页框号，页框号和页内偏移进行拼接，得到物理内存地址（注意要加上一个偏移），然后读取。

3）写
给一个虚拟内存地址（从0开始），将虚拟内存地址拆成页号和页内偏移（前20位是页号，后12位是页内偏移）
首先是根据pid查该进程的内存在页表中的起址，然后比较进程分配得到的页数pageSize和页号，如果越界，那么拒绝访问。如果没有越界，那么由起址+页号得到对应的页框号，页框号和页内偏移进行拼接，得到物理内存地址，然后写入。

4）释放
给一个虚拟内存地址（从0开始），将虚拟内存地址拆成页号和页内偏移（前20位是页号，后12位是页内偏移）
首先是根据pid查该进程的内存在页表中的起址，然后比较进程分配得到的页数pageSize和页号，如果越界，那么拒绝访问。如果没有越界，那么由起址+页号找到对应的页表项，然后将该页表项中的占用位置0，得到页框号，在位示图中将该页框对应的位置0，空闲块数+1，然后将页框号置0。
