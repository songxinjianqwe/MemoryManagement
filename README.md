init：初始化空闲块数，位示图，页表，进程表

空闲块数初始值为页框总数
位示图全部清0
页表：每个页表项中的页框号都置为0，标志位也置0
进程表：1024个表项，全部置0

1）创建
创建一个进程，分配1MB的内存
此时在进程表中开始查找，用进程号作为索引找到对应的进程表项，将进程号填入，然后pageSize就是分配的内存的页框数（向上取整）
先看空闲块数是否还足够，如果不足，直接返回。
如果足够，那么取出页表，然后在页表中找连续的页表项，如果有连续的满足需求的页表项，就把这些然后每个页表项中都要去位示图中的开始找，先看空闲块数是否还足够，如果足够，那么从头遍历找不为0的块，将位示图中的块的占用位置为1，空闲块的位置转为页框号（第一个空闲块对应的是第一个页框），返回页框号，填入页表项，并将页表项的占用标识置为1，主存驻留标识置为1，空闲块数减一。
再看下一个页表项，如此反复直至内存分配完毕。
分配完毕后，返回第一个页表项的索引，填入PCB的页表开始位置。完毕。

返回的虚拟内存地址，是页号和页内偏移的拼接，都是0。

2）读
给一个虚拟内存地址（从0开始），将虚拟内存地址拆成页号和页内偏移（前20位是页号，后12位是页内偏移）
首先是根据pid查该进程的内存在页表中的起址，然后比较进程分配得到的页数pageSize和页号，如果越界，那么拒绝访问。如果没有越界，那么由起址+页号得到对应的页框号，页框号和页内偏移进行拼接，得到物理内存地址（注意要加上一个偏移），然后读取。

3）写
给一个虚拟内存地址（从0开始），将虚拟内存地址拆成页号和页内偏移（前20位是页号，后12位是页内偏移）
首先是根据pid查该进程的内存在页表中的起址，然后比较进程分配得到的页数pageSize和页号，如果越界，那么拒绝访问。如果没有越界，那么由起址+页号得到对应的页框号，页框号和页内偏移进行拼接，得到物理内存地址，然后写入。

4）释放
给一个虚拟内存地址（从0开始），将虚拟内存地址拆成页号和页内偏移（前20位是页号，后12位是页内偏移）
首先是根据pid查该进程的内存在页表中的起址，然后比较进程分配得到的页数pageSize和页号，如果越界，那么拒绝访问。如果没有越界，那么由起址+页号找到对应的页表项，然后将该页表项中的占用位置0，得到页框号，在位示图中将该页框对应的位置0，空闲块数+1，然后将页框号置0。将进程表中的对应项全部清0。

---------------------------------------------------------------------------------------------
实存管理是创建进程时就将给了所有所需的页框，添加了页表项。
虚存管理是创建进程时仅添加页表项，没有分配页框。
当进程需要读写数据时，如果这部分数据已经装入内存，那么直接访问；否则，应该从磁盘中读取，然后装入到内存，分配页框。
如果此时页框不足，那么将部分页框暂时移到磁盘（注意遵循局部性原理）
那么此时，即使内存空间小于进程的需要量，进程也能运行。
代价就是磁盘的装入替换。
此时页表就应该适应磁盘的尺寸，但是页框数仍适应内存的尺寸。


1）分配：
在磁盘中存放进程的映像，其大小为分配的内存大小。

创建一个进程，分配1MB的内存
此时在进程表中开始查找，用进程号作为索引找到对应的进程表项，将进程号填入，然后pageSize就是分配的内存的页框数（向上取整）
取出页表，然后在页表中找连续的页表项，如果有连续的满足需求的页表项，就遍历这些页表项，就把这些然后每个页表项中都要去位示图中的开始找，先看空闲块数是否还足够，如果足够，除了第一个页分配页框外，其他的仅将主存驻留置为0，全部页表项都写入对应的磁盘的物理地址。页表项的占用标识置1
分配完毕后，返回第一个页表项的索引，填入PCB的页表开始位置。完毕。

返回的虚拟内存地址，是页号和页内偏移的拼接，都是0。


2）读：
给一个虚拟内存地址（从0开始），将虚拟内存地址拆成页号和页内偏移（前20位是页号，后12位是页内偏移）
首先是根据pid查该进程的内存在页表中的起址，然后比较进程分配得到的页数pageSize和页号，如果越界，那么拒绝访问。如果没有越界，那么由起址+页号得到对应的页表项，查看页表项的主存驻留标识，如果为1，那么取出对应的页框号，页框号和页内偏移进行拼接，得到物理内存地址（注意要加上一个偏移），然后读取，置引用位为1。
如果主存驻留标识不为1，那么发出缺页中断。
缺页中断处理程序会拿到页表项中的磁盘物理地址，查看内存空闲的页框数，如果有剩余，那么找到一个空闲的页框，将磁盘块上的数据拷贝到页框中，返回页框号，修改位示图和空闲块数，将引用位置1。以下步骤相同。
如果没有剩余，那么使用时钟算法（可以先使用从头遍历的方式做，之后再补充）淘汰一页。检查该页的修改标识，如果修改标识为1，就把该页框中的数据拷贝到对应的磁盘物理地址中，然后将主存驻留标识置0。之后再分配页框。

3）写：
同读，区别是缺页中断时不仅要引用位置1，还要将修改位置1

4）释放：
给一个虚拟内存地址（从0开始），将虚拟内存地址拆成页号和页内偏移（前20位是页号，后12位是页内偏移）
首先是根据pid查该进程的内存在页表中的起址，然后比较进程分配得到的页数pageSize和页号，如果越界，那么拒绝访问。如果没有越界，那么由起址+页号找到对应的页表项，
然后将该页表项中的占用位置0，如果主存驻留标识为0，那么结束当前页表项。如果主存驻留标识为1，那么得到页框号，在位示图中将该页框对应的位置0，空闲块数+1，然后将页框号置0。将进程表中的对应项全部清0。

然后清空磁盘上的进程映像。


